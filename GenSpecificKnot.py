#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Filename: GenSpecificKnot.py
Author: Yuzhou He <ribosomehyz@gmail.com>

Purpose:
  Randomly generate equilateral open polylines (N vertices), classify each with
  TopoLy (Jones + reduction), keep only those matching a target knot type (e.g., '6_3'),
  and save to: specific_type/N=<N>/<target_type>/.

Usage:
  python GenSpecificKnot.py --N 200 --num 100 --target 6_3 --max-attempts 500000
  # Common options:
  #   --edge 1.0                 # edge length
  #   --closure CLOSED           # TopoLy closure
  #   --tries 1                  # randomized closure repeats
  #   --reduce-method KMT        # TopoLy simplification
  #   --max-cross 15             # crossing cap
  #   --run-parallel 1           # use parallel TopoLy backend (0/1)
  #   --out-root specific_type   # output root
  #   --seed 42                  # RNG seed
  #   --max-attempts 500000      # hard cap on attempts

Requirements:
  - Python 3.9+
  - numpy
  - topoly  (pip install topoly)

Notes:
  - Output naming: <target>_N<N>_<#####>.xyz under specific_type/N=<N>/<target>/.
  - Hit-rate and progress are printed periodically.
"""

from __future__ import annotations

import os
import argparse
import random
import string
import numpy as np

# --- dependency check ---
try:
    import topoly as tp
except Exception as e:
    raise SystemExit("Topoly is required. Try: pip install topoly\n" + str(e))


# --- utils ---
def safe_folder_name(s: str) -> str:
    """Restrict to filesystem-safe characters."""
    allowed = set(string.ascii_letters + string.digits + "._-()")
    return "".join(ch if ch in allowed else "_" for ch in (s or "")) or "_UNKNOWN"


def write_xyz(path: str, P: np.ndarray, element: str = "C") -> None:
    """Write simple XYZ with header line count and comment."""
    os.makedirs(os.path.dirname(path), exist_ok=True)
    N = int(P.shape[0])
    with open(path, "w", encoding="utf-8") as f:
        f.write(f"{N}\n")
        f.write("generated by GenSpecificKnot.py\n")
        for x, y, z in P:
            f.write(f"{element} {x:.8f} {y:.8f} {z:.8f}\n")


def identify_type(
    P: np.ndarray,
    closure: str | int = "CLOSED",
    tries: int = 1,
    reduce_method: str | int = "KMT",
    max_cross: int = 15,
    run_parallel: bool = False,
) -> str:
    """Classify a polyline with TopoLy; return the most probable knot label or '_UNKNOWN'."""
    try:
        cls = getattr(tp.params.Closure, closure) if isinstance(closure, str) else closure
        red = getattr(tp.params.ReduceMethod, reduce_method) if isinstance(reduce_method, str) else reduce_method
        res = tp.jones(
            P.tolist(),
            closure=cls,
            tries=int(tries),
            reduce_method=red,
            max_cross=int(max_cross),
            translate=True,
            run_parallel=bool(run_parallel),
        )
        if isinstance(res, dict) and res:
            # choose the label with the largest score
            return max(res.items(), key=lambda kv: kv[1])[0]
        return str(res) if res else "_UNKNOWN"
    except Exception:
        return "_UNKNOWN"


def generate_equilateral_open_polyline(N: int, edge: float = 1.0) -> np.ndarray:
    """Generate an OPEN equilateral random polyline with N vertices (N-1 edges)."""
    if N < 3:
        raise ValueError("N must be >= 3")
    u = np.random.normal(size=(N - 1, 3))
    u /= np.linalg.norm(u, axis=1, keepdims=True)
    steps = edge * u
    pts = np.vstack([np.zeros((1, 3)), np.cumsum(steps, axis=0)])
    # center the polyline
    pts -= pts.mean(axis=0, keepdims=True)
    return pts


# --- main ---
def main() -> None:
    ap = argparse.ArgumentParser(
        description="Generate random polylines, classify with TopoLy, and keep only a target knot type."
    )
    ap.add_argument("--N", type=int, required=True, help="Number of vertices per knot (>=3)")
    ap.add_argument("--num", type=int, required=True, help="How many knots of the target type to save")
    ap.add_argument("--target", type=str, required=True, help="Target knot type label (e.g., 3_1, 4_1, 6_3)")
    ap.add_argument("--edge", type=float, default=1.0, help="Edge length for equilateral steps")
    ap.add_argument("--closure", type=str, default="CLOSED", help="TopoLy closure method")
    ap.add_argument("--tries", type=int, default=1, help="Randomized closure repeats")
    ap.add_argument("--reduce-method", type=str, default="KMT", help="TopoLy simplification method")
    ap.add_argument("--max-cross", type=int, default=15, help="Max allowed crossings")
    ap.add_argument("--run-parallel", type=int, default=0, help="Enable parallel TopoLy (0/1)")
    ap.add_argument("--out-root", type=str, default="specific_type", help="Output root directory")
    ap.add_argument("--seed", type=int, default=None, help="Random seed")
    ap.add_argument(
        "--max-attempts",
        type=int,
        default=None,
        help="Hard cap on total attempts (default: num * 1000)",
    )
    args = ap.parse_args()

    if args.N < 3:
        raise SystemExit("--N must be >= 3")

    if args.seed is not None:
        random.seed(args.seed)
        np.random.seed(args.seed)

    target = args.target.strip()
    target_folder = safe_folder_name(target)
    out_dir = os.path.join(args.out_root, f"N={args.N}", target_folder)
    os.makedirs(out_dir, exist_ok=True)

    # attempts cap
    max_attempts = args.max_attempts if args.max_attempts is not None else args.num * 1000

    saved = 0
    attempts = 0
    while saved < args.num and attempts < max_attempts:
        attempts += 1
        P = generate_equilateral_open_polyline(args.N, edge=args.edge)
        tval = identify_type(
            P,
            closure=args.closure,
            tries=args.tries,
            reduce_method=args.reduce_method,
            max_cross=args.max_cross,
            run_parallel=bool(args.run_parallel),
        )
        if tval == target:
            saved += 1
            fname = f"{target}_N{args.N}_{saved:05d}.xyz"
            write_xyz(os.path.join(out_dir, fname), P)
            hit_rate = saved / attempts
            print(f"[OK] {fname} ({saved}/{args.num}) after {attempts} tries | hit-rate={hit_rate:.6f}")

        if attempts % 5000 == 0 and saved < args.num:
            print(f"[Info] attempts={attempts}, saved={saved}, hit-rate={saved/attempts if attempts else 0:.6f}")

    # summary
    if saved < args.num:
        print(f"[WARN] Stopped after {attempts} attempts (cap={max_attempts}). Saved {saved}/{args.num}.")
    else:
        print(f"[OK] Reached target {args.num} in {attempts} attempts.")
    print(f"[Done] Output: {os.path.abspath(out_dir)}")


if __name__ == "__main__":
    main()
